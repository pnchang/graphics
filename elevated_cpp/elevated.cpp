// discompiled 'elevated'
// see original at http://www.pouet.net/prod.php?which=52938
#define WINVER			0x0501
#define _WIN32_WINNT	0x0501
#define WIN32_LEAN_AND_MEAN


#include <windows.h>
#include <mmsystem.h>
#include <d3d9.h>
#include <d3dx9.h>

#pragma comment(lib, "winmm.lib")
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")

extern "C" int _fltused = 0;

static const char edit[]	= "edit";
static const char vs_3_0[]	= "vs_3_0";
static const char ps_3_0[]	= "ps_3_0";
static char functionName[]	= "m0";

static D3DPRESENT_PARAMETERS d3dPresentPrameters = {
	1024, 768, D3DFMT_A8R8G8B8, 2, D3DMULTISAMPLE_NONE, 0,
	D3DSWAPEFFECT_DISCARD, 0, 0, TRUE, D3DFMT_D24X8, 0, 0, 1,
};

struct Vars {
	LPDIRECT3DDEVICE9		device;
	ID3DXBuffer*			vertexShaderBuffer;
	IDirect3DVertexShader9*	vertexShader;
	ID3DXBuffer*			pixelShaderBuffer[4];
	IDirect3DPixelShader9*	pixelShader[4];
	struct {
		IDirect3DTexture9*	texture;
		IDirect3DSurface9*	surface;
	} tex0;
	struct {
		IDirect3DTexture9*	texture;
		IDirect3DSurface9*	surface;
	} tex1;
	struct {
		IDirect3DSurface9*	surface;
	} rt;
	struct {
		IDirect3DSurface9*	surface;
	} backBuffer;
	LPD3DXMESH				mesh;
};

static Vars			vars;
static D3DXVECTOR4	constantBuffer[256];
static D3DXMATRIX	perspectiveMatrix;

#define DEVICE	vars.device


static const char shaderCode[] =
"sampler t0,t1,t2;"
"float4 q[16];"
"float4x4 v:register(c16);"

"float3 no(float2 p){"
	"float2 f=p-floor(p);"
	"float2 u=f*f*f*(f*(f*6-15)+10);"
	"float a=tex2Dlod(t0,float4((floor(p)+float2(0,0))/256,0,0));"
	"float b=tex2Dlod(t0,float4((floor(p)+float2(1,0))/256,0,0));"
	"float c=tex2Dlod(t0,float4((floor(p)+float2(0,1))/256,0,0));"
	"float d=tex2Dlod(t0,float4((floor(p)+float2(1,1))/256,0,0));"
	"return float3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,30*f*f*(f*(f-2)+1)*(float2(b-a,c-a)+(a-b-c+d)*u.yx));"
"}"

"float f(float2 p,float o){"
	"float2 d=0;"
	"float a=0;"
	"float b=3;"
	"for(float i=0; i<o; i++){"
		"float3 n=no(.25*p);"
		"d+=n.yz;"
		"a+=(b*=.5)*n.x/(1+mul(d,d));"
		"p=mul(float2x2(1.6,-1.2,1.2,1.6),p);"
	"}"
	"return a;"
"}"

"float3 cn(float2 p,float e,float o){"
	"float a=f(p,o);"
	"return normalize(float3(q[2].w*(a-f(p+float2(e,0),o)),e,q[2].w*(a-f(p+float2(0,e),o))));"
"}"

"float3 b(float3 p,float3 c,float3 d){"
	"float a=mul(d,q[3]);"
	"float b=lerp(a,mul(c,q[3]),.5+.5*q[2].x);"
	"return float3(.13,.18,.22)*(c.y+.25*saturate(-b)-.1*no(1024*p.xz).y)+float3(1.4,1,.7)*saturate(b)*saturate(2*a);"
"}"

"float4 m0(float4 x:position,out float4 y:color):position{"
	"x.z=q[2].w*f(x.yx,8);"
	"y=x.yzxw;"
	"return mul(v,y);"
"}"

"float4 m1(float2 x:vpos):color{"
	"float2 o=q[0]+x.x*.37;"
	"float3 c;"
	"float t=q[3].w*q[0].z;"
	"c.x=16*cos(t*tex2D(t0,o+=.1)+3*tex2D(t0,o+=.1))+8*cos(t*tex2D(t0,o+=.1)*2+3*tex2D(t0,o+=.1));"
	"c.z=16*cos(t*tex2D(t0,o+=.1)+3*tex2D(t0,o+=.1))+8*cos(t*tex2D(t0,o+=.1)*2+3*tex2D(t0,o+=.1));"
	"c.y=q[2].w*f(c.xz,3)+q[1].x+q[1].y*x.x;"
	"o+=q[3].w*.5;"
	"c.x+=.002*no(o+=.1);"
	"c.y+=.002*no(o+=.1);"
	"c.z+=.002*no(o+=.1);"
	"return float4(c,.3*cos(t*2));"
"}"

"float4 m2(float4 y:color):color{"
	"return y;"
"}"

"float4 m3(float2 x:texcoord):color{"
	"float2 o=x+.5/1280;"
	"float4 d=tex2D(t1,o);"
	"float3 e=normalize(mul(v,float4(x.x*2-1,-x.y*2+1,1,1)));"
	"float2 s=e.xz/e.y;"
	"float k=(2*s.y+1000)%8;"
	"float3 c=float3(.55,.65,.75)+.1*f(s+q[3].w*.2,10)+.5*pow(1-e.y,8)+pow(saturate(mul(e,q[3])),16)*float3(.4,.3,.1)+float4(1+.4*k,2,3+.5*k,0)*(1-cos(12.5664*s.y))*saturate(1-abs(s.y)/10-abs(s.x+q[5+k].x*.0012-8)/20)*exp(-q[5+k].x*.0002);"
	"if(d.w>.5){"
		"float t=length(d.xyz-q[4].xyz);"
		"float w=q[1].w-d.y;"
		"if(w<0){"
			"float3 n=cn(d.xz,.001*t,12-log2(t));"
			"float h=f(3*d.xz,3);"
			"float r=no(666*d.xz);"
			"c=(.1+.75*q[2].x)*(.8+.2*r);"
			"c=lerp(c,lerp(float3(.8,.85,.9),float3(.45,.45,.2)*(.8+.2*r),q[2].x),smoothstep(.5-.8*n.y,1-1.1*n.y,h*.15));"
			"c=lerp(c,lerp(float3(.37,.23,.08),float3(.42,.4,.2),q[2].x)*(.5+.5*r),smoothstep(0,1,50*(n.y-1)+(h+q[2].x)/.4));"
			"c*=b(d,n,cn(d.xz,.001*t,5));"
		"} else {"
			"t=(q[1].w-q[4].y)/e.y;"
			"d=q[4]+e.xyzz*t;"
			"float3 n=normalize(cn(float2(512,32)*d.xz+saturate(w*60)*float2(q[3].w,0),.001*t,4)*float3(1,6,1));"
			"c=.12*(float3(.4,1,1)-float3(.2,.6,.4)*saturate(w*16));"
			"c*=.3+.7*q[2].x;"
			"c+=pow(1-mul(-e,n),4)*(pow(mul(q[3],reflect(-e,n)),32)*float3(.32,.31,.3)+.1);"
			"c=lerp(c,b(d,n,n),smoothstep(1,0,q[2].x+w*60-f(666*d.xz+saturate(w*60)*float2(q[3].w,0)*2,5))*.5);"
		"}"
		"c*=.7+.3*smoothstep(0,1,256*abs(w));"
		"c*=exp(-.042*t);"
		"c+=(1-exp(-.1*t))*(float3(.52,.59,.65)+pow(saturate(mul(e,q[3])),8)*float3(.6,.4,.1));"
	"}"
	"return float4(c,0);"
"}"

"float4 m4(float2 x:texcoord):color{"
	"float2 o=x+.5/1280;"
	"float4 d=tex2D(t1,o);"
	"float3 c=tex2D(t2,o);"
	"if(d.w>.5) {"
		"d=mul(v,float4(d.xyz,1));"
		"d.y*=-1;"
		"c=0;"
		"for(float i=0; i<16; i++) {"
			"c.x+=tex2D(t2,o+i*(.5+.5*d.xy/d.w-o)/16+float2(2,0)/1280).x;"
			"c.y+=tex2D(t2,o+i*(.5+.5*d.xy/d.w-o)/16).y;"
			"c.z+=tex2D(t2,o+i*(.5+.5*d.xy/d.w-o)/16+float2(-2,0)/1280).z;"
		"}"
		"c/=16;"
	"}"
	"c=pow(c,.45)*q[2].z+q[2].y;"
	"c*=.4+9.6*o.x*o.y*(1-o.x)*(1-o.y);"
	"c.xz*=.98;"
	"float w=tex2D(t0,q[3].w*.1);"
	"o+=w;"
	"c-=.005*w;"
	"c.x+=.01*tex2D(t0,o+=.1);"
	"c.y+=.01*tex2D(t0,o+=.1);"
	"c.z+=.01*tex2D(t0,o+=.1);"
	"return float4(c,0);"
"}"
;


struct Vertex {
	float	x, y, z;
	float	nx, nv, nz;
};

static const Vertex vertex[] = {
	{	   0.0f,	  0.0f,	0.0f,	1.0f,	0.0f,	0.0f,	},
	{	1024.0f,	  0.0f,	0.0f,	1.0f,	1.0f,	0.0f,	},
	{	   0.0f,	576.0f,	0.0f,	1.0f,	0.0f,	1.0f,	},
	{	1024.0f,	576.0f,	0.0f,	1.0f,	1.0f,	1.0f,	},
};

static const Vertex vertex2[] = {
	{	   0.0f,	 96.0f,	0.0f,	1.0f,	0.0f,	0.0f,	},
	{	1024.0f,	 96.0f,	0.0f,	1.0f,	1.0f,	0.0f,	},
	{	   0.0f,	672.0f,	0.0f,	1.0f,	0.0f,	1.0f,	},
	{	1024.0f,	672.0f,	0.0f,	1.0f,	1.0f,	1.0f,	},
};


static const unsigned char script[][15] = {
	{ 0x08,	0x40, 0x00,		0x62, 0x00, 0x01, 0x35, 0x04, 0x20, 0x40, 0x9A, 0x00, 0x00, 0x96, 0xC8, },
	{ 0x08,	0x00, 0x00,		0x62, 0x00, 0x01, 0x35, 0x04, 0x20, 0x40, 0x9A, 0x00, 0x80, 0x96, 0xC8, },
	{ 0x0A,	0x00, 0x00,		0x05, 0x00, 0x01, 0xA0, 0x80, 0xFF, 0x40, 0x9A, 0x00, 0x80, 0x96, 0xC8, },
	{ 0x06,	0x00, 0x00,		0x05, 0x00, 0x01, 0x08, 0x09, 0x80, 0x5A, 0xC8, 0x00, 0x6E, 0x96, 0x8C, },
	{ 0x0C,	0x00, 0x00,		0x11, 0x00, 0x01, 0x08, 0x04, 0x80, 0x20, 0x00, 0x00, 0x6E, 0x96, 0xC8, },
	{ 0x0C,	0x00, 0x00,		0x71, 0x00, 0x01, 0x08, 0x05, 0x80, 0x20, 0x00, 0x00, 0x6E, 0x96, 0xC8, },
	{ 0x06,	0x00, 0x00,		0x6C, 0x00, 0x01, 0x08, 0x05, 0x80, 0x20, 0x00, 0x00, 0x6E, 0x96, 0xC8, },
	{ 0x0A,	0x00, 0x00,		0x12, 0x00, 0x01, 0x04, 0x05, 0x80, 0x38, 0x00, 0x00, 0x20, 0xFA, 0xC8, },
	{ 0x03,	0x00, 0x00,		0x09, 0x00, 0x01, 0x04, 0x0E, 0x7F, 0xA0, 0xAA, 0x00, 0x5A, 0xB4, 0xC8, },
	{ 0x05,	0x00, 0x00,		0x09, 0x00, 0x01, 0x02, 0x0E, 0x7F, 0xA0, 0xAA, 0x00, 0x5A, 0xB4, 0xC8, },
	{ 0x03,	0x00, 0x00,		0x69, 0x00, 0x01, 0x14, 0x0E, 0x7F, 0x40, 0xAA, 0x00, 0x5A, 0xB4, 0xC8, },
	{ 0x05,	0x00, 0x00,		0x69, 0x00, 0x01, 0x0C, 0x0E, 0x7F, 0x40, 0xAA, 0x00, 0x5A, 0xB4, 0xC8, },
	{ 0x04,	0x00, 0x00,		0x06, 0x00, 0x01, 0x08, 0x20, 0x80, 0xA0, 0xAA, 0x00, 0x5A, 0xB4, 0xC8, },
	{ 0x0A,	0x20, 0x00,		0x65, 0x00, 0x05, 0x3C, 0x08, 0x80, 0xB4, 0x00, 0x00, 0x6E, 0x00, 0xC8, },
	{ 0x02,	0x00, 0x00,		0x65, 0x00, 0x05, 0x3C, 0x08, 0x80, 0xB4, 0x00, 0x00, 0x6E, 0xA0, 0xC8, },
	{ 0x10,	0x00, 0x00,		0xBA, 0x00, 0x04, 0x3C, 0x08, 0x80, 0x8C, 0x00, 0x00, 0x6E, 0xA0, 0xC8, },
	{ 0x14,	0x00, 0x00,		0x0C, 0x00, 0x04, 0x18, 0x08, 0x80, 0xA5, 0x00, 0x00, 0x80, 0x80, 0xFF, },
	{ 0x0A,	0x00, 0x00,		0x51, 0x00, 0x18, 0x12, 0x50, 0x6A, 0x6E, 0x00, 0x00, 0x5A, 0xBE, 0xFF, },
	{ 0x0A,	0x00, 0x00,		0x62, 0x01, 0x3A, 0x1C, 0x8C, 0x6C, 0x50, 0x00, 0x00, 0x5A, 0xBE, 0xFF, },
	{ 0x07,	0x60, 0x00,		0x62, 0x01, 0x3A, 0x1C, 0x8C, 0x6C, 0x50, 0x00, 0x00, 0x5A, 0xBE, 0xFF, },
	{ 0x01,	0x00, 0x00,		0x62, 0x01, 0x3A, 0x1C, 0x8C, 0x6C, 0x50, 0x00, 0x00, 0x00, 0x82, 0xFF, },
	{ 0x1C,	0x00, 0x00,		0x99, 0x01, 0x57, 0x30, 0x10, 0x73, 0x69, 0x78, 0x00, 0x80, 0xA0, 0xFF, },
	{ 0x10,	0x00, 0x00,		0x72, 0x01, 0xFF, 0xA0, 0x08, 0x80, 0x32, 0xA0, 0x00, 0x78, 0x8C, 0xFF, },
	{ 0x10,	0x00, 0x00,		0x30, 0x01, 0xFF, 0x78, 0x08, 0x80, 0x32, 0x28, 0x00, 0x78, 0x8C, 0xFF, },
	{ 0x16,	0x00, 0x00,		0x53, 0x01, 0xBC, 0x40, 0x08, 0x80, 0x0A, 0x28, 0x00, 0x69, 0xB4, 0xFF, },
	{ 0x01,	0x40, 0x00,		0x53, 0x01, 0xBC, 0x40, 0x08, 0x80, 0x0A, 0x28, 0x00, 0x69, 0xB4, 0xFF, },
	{ 0x09,	0x00, 0x00,		0x53, 0x01, 0xBC, 0x40, 0x08, 0x80, 0x0A, 0x28, 0x00, 0x80, 0xB4, 0xFF, },
	{ 0x08,	0x00, 0x00,		0x0B, 0x01, 0xFF, 0x80, 0x08, 0x80, 0x96, 0x28, 0x00, 0x64, 0xB4, 0xDC, },
	{ 0x08,	0x00, 0x00,		0x08, 0x01, 0xFF, 0x80, 0x04, 0xC8, 0x96, 0x28, 0x00, 0x64, 0xB4, 0xDC, },
	{ 0x10,	0x00, 0x00,		0x16, 0x01, 0xFF, 0x80, 0x10, 0x80, 0x55, 0x28, 0x00, 0x64, 0xB4, 0xDC, },
	{ 0x01,	0xA0, 0x00,		0x0B, 0x01, 0x10, 0x35, 0x10, 0x80, 0x40, 0x28, 0x00, 0x64, 0x00, 0xFF, },
	{ 0x07,	0x00, 0x00,		0x0B, 0x01, 0x10, 0x35, 0x10, 0x80, 0x40, 0x28, 0x00, 0x64, 0xBE, 0xFF, },
	{ 0x08,	0x80, 0x00,		0x0B, 0x01, 0x10, 0x35, 0x30, 0x6F, 0x40, 0x28, 0x40, 0x64, 0xBE, 0xFF, },
	{ 0x0E,	0x80, 0x00,		0x03, 0x00, 0x40, 0x35, 0xBE, 0x50, 0xAA, 0xB4, 0x80, 0x18, 0xFF, 0xFF, },
	{ 0x06,	0x00, 0x00,		0x03, 0x00, 0x40, 0x35, 0xBE, 0x50, 0xAA, 0xB4, 0xFF, 0x18, 0xFF, 0xFF, },
	{ 0x10,	0x00, 0x00,		0x09, 0x00, 0xB3, 0x78, 0x0E, 0x50, 0x64, 0xB4, 0xFF, 0x78, 0x96, 0x14, },
	{ 0x10,	0x00, 0x00,		0x32, 0x01, 0xB3, 0x78, 0x14, 0x64, 0xAA, 0x00, 0xFF, 0x78, 0x96, 0x14, },
	{ 0x20,	0x00, 0x00,		0x01, 0x00, 0xE2, 0x78, 0x0E, 0x78, 0x00, 0xC1, 0xFF, 0x6E, 0xAA, 0xE6, },
	{ 0x20,	0x80, 0x00,		0x7D, 0x00, 0x1E, 0x78, 0x0E, 0x78, 0x23, 0xAA, 0xFF, 0x64, 0xB4, 0xE6, },
	{ 0x18,	0x60, 0x00,		0x7D, 0x00, 0x1E, 0x78, 0x0E, 0x78, 0x23, 0xAA, 0x00, 0x64, 0xB4, 0xE6, },
	{ 0xFF,	0x00, 0x00,		0x7D, 0x00, 0x1E, 0x78, 0x0E, 0x78, 0x23, 0xAA, 0x00, 0x00, 0x80, 0xE6, },
};


static const short coefs[][2] = {
	{ 0x0000, 0x0100, },
	{ 0x0000, 0x0100, },
	{ 0x0000, 0x1000, },
	{ 0x0000, 0x0060, },
	{ 0x0000, 0x0040, },
	{ 0x0080, 0x0004, },
	{ 0x0000, 0x0020, },
	{ 0x00C0, 0x0080, },
	{ 0x0000, 0x0100, },
	{ 0x0080, 0x0080, },
	{ 0x0000, 0x0080, },
	{ 0x0080, 0x0080, },
	{ 0x0200, 0x0087, },
	{ 0x0000, 0x0248, },
	{ 0x0000, 0x0000, },
	{ 0x0000, 0x0000, },
	{ 0x0000, 0x0000, },
	{ 0x0000, 0x0000, },
	{ 0x0000, 0x0000, },
	{ 0x0000, 0x0000, },
	{ 0x0001, 0x0002, },
	{-0x53BC, 0x0000, },
	{-0x4EF0, 0x0002, },
	{ 0x0004, 0x0010, },
};

static const unsigned char song[] = {
	                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x05,
	0x04, 0x05, 0x04, 0x05, 0x06, 0x04, 0x05, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x04, 0x05, 0x07,
	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x04, 0x05, 0x04, 0x05, 0x09, 0x0A, 0x07, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x04, 0x0D,
	0x0E, 0x0F, 0x09, 0x0A, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const unsigned char seq[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 0x7F, 0x3D, 0x7F, 0x00, 0x00, 0x00, 0x00,
	0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x00, 0x4A, 0x00, 0x00, 0x00, 0x4F, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 0x4A, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00,
	0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x48, 0x00, 0x00, 0x00, 0x52, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00,
	0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x00, 0x4A, 0x00, 0x00, 0x00, 0x4B, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00,
	0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x4A, 0x00, 0x00, 0x00, 0x4D, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x4A, 0x00, 0x00, 0x00,
	0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x4D, 0x00, 0x00, 0x00, 0x54, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4A, 0x00, 0x00, 0x00,
	0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x00, 0x45, 0x00, 0x00, 0x00, 0x46, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00,
	0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x4A, 0x00, 0x00, 0x00, 0x4D, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
};

#ifdef MINGW
static double msinf(float x) {
	double	y;
	asm (
		"flds	%1; "
		"fsin	; "
		"fstpl	%0; "
		: "=m"(y)
		: "m"(x) 
		:
	);
	return	y;
}


static double mcosf(float x) {
	double	y;
	asm __volatile__ (
		"flds	%1; "
		"fcos	; "
		"fstpl	%0; "
		: "=m"(y)
		: "m"(x)
		:
	);
	return	y;
}

#else

static __forceinline double msinf(float x) {
	__asm {
		fld		dword ptr [x]
		fsin
	}
}


static __forceinline double mcosf(float x) {
	__asm {
		fld		dword ptr [x]
		fcos
	}
}
#endif

static void WINAPI noise(D3DXVECTOR4* pOut, const D3DXVECTOR2* pTexCoord, const D3DXVECTOR2* pTexelSize, void* data) {
	static unsigned int a = 0;
	a *= 0x3fb3;
	a += 0x0011;

	int t = (int) (short) ((a >> 14) & 0xffff);
	float f = ((float)t) * (1.0f / 32768.0f);

	pOut->x = f;
}


static void initRender() {
	D3DXCompileShader(shaderCode, sizeof(shaderCode), 0, 0, functionName, vs_3_0, 0, &vars.vertexShaderBuffer, 0, 0);
	DEVICE->CreateVertexShader((const DWORD*) vars.vertexShaderBuffer->GetBufferPointer(), &vars.vertexShader);

	for(int i = 0; i < 4; ++i) {
		functionName[1] += 1;
		D3DXCompileShader(shaderCode, sizeof(shaderCode), 0, 0, functionName, ps_3_0, 0, &vars.pixelShaderBuffer[i], 0, 0);
		DEVICE->CreatePixelShader((const DWORD*) vars.pixelShaderBuffer[i]->GetBufferPointer(), &vars.pixelShader[i]);
	}

	DEVICE->CreateTexture(1024, 576, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A32B32G32R32F, D3DPOOL_DEFAULT, &vars.tex0.texture, 0);
	vars.tex0.texture->GetSurfaceLevel(0, &vars.tex0.surface);

	DEVICE->CreateTexture(1024, 576, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &vars.tex1.texture, 0);
	vars.tex1.texture->GetSurfaceLevel(0, &vars.tex1.surface);

	DEVICE->CreateRenderTarget(2, 1, D3DFMT_A32B32G32R32F, D3DMULTISAMPLE_NONE, 0, TRUE, &vars.rt.surface, 0);
	DEVICE->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &vars.backBuffer.surface);

	D3DXCreatePolygon(DEVICE, 52.0f, 4, &vars.mesh, 0);
	vars.mesh->CloneMeshFVF(D3DXMESH_32BIT, D3DFVF_XYZ | D3DFVF_NORMAL, DEVICE, &vars.mesh);
	D3DXTessellateNPatches(vars.mesh, 0, 512.0f, FALSE, &vars.mesh, 0);

	IDirect3DTexture9* texture;
	DEVICE->CreateTexture(256, 256, 1, 0, D3DFMT_R16F, D3DPOOL_MANAGED, &texture, 0);
	D3DXFillTexture(texture, noise, 0);

	DEVICE->SetTexture(0, texture);
	DEVICE->SetTexture(D3DVERTEXTEXTURESAMPLER0, texture);

	DEVICE->SetSamplerState(2, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
	DEVICE->SetSamplerState(2, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
}


static void calcView(void* d) {
	DEVICE->SetRenderTarget(0, vars.rt.surface);
	DEVICE->SetPixelShaderConstantF(0, &constantBuffer[0][0], 64);
	DEVICE->SetPixelShader(vars.pixelShader[0]);
	DEVICE->SetFVF(D3DFVF_TEX1 | D3DFVF_XYZRHW);
	DEVICE->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertex[0], sizeof(vertex[0]));

	D3DLOCKED_RECT lockedRect;
	vars.rt.surface->LockRect(&lockedRect, 0, 0);

	const D3DXVECTOR4* s = (const D3DXVECTOR4*) lockedRect.pBits;

	* (D3DXVECTOR4*) d = *s;

	perspectiveMatrix.m[0][1] = (float) mcosf(s->w);
	perspectiveMatrix.m[0][0] = (float) msinf(s->w);
	D3DXMatrixLookAtLH(
		  (D3DXMATRIX*)  &constantBuffer[16][0]
		, (D3DXVECTOR3*) &s[0]
		, (D3DXVECTOR3*) &s[1]
		, (D3DXVECTOR3*) &perspectiveMatrix.m[0]
	);

	D3DXMatrixPerspectiveFovLH(
		  &perspectiveMatrix
		, * (float*) &constantBuffer[0][3]
		, 1.75f
		, 1.0f / 32.0f
		, 256.0f
	);

	D3DXMatrixMultiply((D3DXMATRIX*) &constantBuffer[16][0], (D3DXMATRIX*) &constantBuffer[16][0], &perspectiveMatrix);

	vars.rt.surface->UnlockRect();
}


static void updateRender(int t) {
	DEVICE->BeginScene();

	{
		float* d = &constantBuffer[0][0];
		const unsigned char* p = &script[0][0];

		for(int tt = t; tt >= 0; ) {
			int dt = *p++ * 20840;
			int dx = * (unsigned short*) p;
			p += 2;

			for(int i = 0; i < 12; ++i) {
				float f = (float) *p++;

				dx += dx;
				if(dx & 0x00010000) {
					float b = (float) p[0x0e];
					b -= f;
					b /= (float) dt;
					b *= (float) tt;
					f += b;
				}

				f -= coefs[i][0];
				f /= coefs[i][1];
				d[i] = f;
			}

			tt -= dt;
		}
	}

	constantBuffer[3][0] = (float) mcosf(constantBuffer[1][2]);
	constantBuffer[3][1] = 1.0f / 32.0f;
	constantBuffer[3][2] = (float) msinf(constantBuffer[1][2]);
	constantBuffer[3][3] = ((float) t) / 44100.0f;

	calcView(&constantBuffer[4][0]);

	{
		float * d = (float*) &constantBuffer[5][0];
		for(int i = 0; i < 32; ++i) {
			d[i] = (float) t;
		}

		for(int k = t, c = 0; k >= 0; k -= 5210, ++c) {
			int a = song[c>>4];
			int b = seq[a*16 + (c&0x0f)];
			if(b != 0) {
				d[(b&7) * 4] = (float) k;
			}
		}
	}

	DEVICE->SetVertexShaderConstantF(0, &constantBuffer[0][0], 64);
	DEVICE->SetVertexShader(vars.vertexShader);
	DEVICE->SetRenderTarget(0, vars.tex0.surface);
	DEVICE->SetPixelShaderConstantF(0, &constantBuffer[0][0], 64);
	DEVICE->SetPixelShader(vars.pixelShader[1]);
	DEVICE->Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0, 1.0f, 0);
	vars.mesh->DrawSubset(0);

	D3DXMatrixInverse((D3DXMATRIX*) &constantBuffer[16][0], 0, (D3DXMATRIX*) &constantBuffer[16][0]);
	DEVICE->SetRenderTarget(0, vars.tex1.surface);
	DEVICE->SetPixelShaderConstantF(0, &constantBuffer[0][0], 64);
	DEVICE->SetPixelShader(vars.pixelShader[2]);
	DEVICE->SetTexture(1, vars.tex0.texture);
	DEVICE->SetFVF(D3DFVF_TEX1 | D3DFVF_XYZRHW);
	DEVICE->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertex[0], sizeof(vertex[0]));

	constantBuffer[3][3] += 0.0417480468750f;
	calcView(&constantBuffer[4][0]);

	DEVICE->SetRenderTarget(0, vars.backBuffer.surface);
	DEVICE->Clear(0, 0, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0, 1.0f, 0);
	DEVICE->SetPixelShaderConstantF(0, &constantBuffer[0][0], 64);
	DEVICE->SetPixelShader(vars.pixelShader[3]);
	DEVICE->SetTexture(2, vars.tex1.texture);
	DEVICE->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertex2[0], 24);

	DEVICE->EndScene();
	DEVICE->Present(0, 0, 0, 0);
}


extern "C" void __cdecl WinMainCRTStartup() {
	IDirect3D9_CreateDevice(
		  Direct3DCreate9(D3D_SDK_VERSION)
		, D3DADAPTER_DEFAULT
		, D3DDEVTYPE_HAL
		, CreateWindowExA(0,edit,0,0,0,0,0,0,0,0,0,0)
		, D3DCREATE_HARDWARE_VERTEXPROCESSING
		, &d3dPresentPrameters
		, &DEVICE
	);

	initRender();
	ShowCursor(0);

	unsigned int t0 = timeGetTime();

	do {
		int t = ((timeGetTime()-t0) * 441) / 10;
		if(t >= 0x00910000) {
			break;
		}
		updateRender(t);
	} while(GetAsyncKeyState(VK_ESCAPE) == 0);

	ExitProcess(0);
}

